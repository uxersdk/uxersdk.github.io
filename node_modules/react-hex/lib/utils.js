'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gridPoints = exports.gridPoint = exports.hexCorners = exports.corners = undefined;

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _from = require('babel-runtime/core-js/array/from');

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-mixed-operators,consistent-return */

var THETAS = [0, 1, 2, 3, 4, 5].map(function (i) {
  return Math.PI / 3 * i;
});
var POINTY = 'pointy-topped';
var FLAT = 'flat-topped';
var RANGE6 = [0, 60, 120, 180, 240, 300];
var SQRT3 = Math.sqrt(3);

var getDiff = function getDiff(type) {
  if (type === POINTY) return Math.PI / 6;
  if (type === FLAT) return 0;
};
var range = function range(n) {
  return (0, _from2.default)(Array(n).keys());
};
var product = function product(p, q) {
  var l = [];
  range(p).forEach(function (i) {
    range(q).forEach(function (j) {
      l.push([i, j]);
    });
  });
  return l;
};

var corners = exports.corners = function corners(type, x, y, size) {
  var diff = getDiff(type);
  return THETAS.map(function (theta) {
    return theta + diff;
  }).map(function (theta) {
    return [x + size * Math.cos(theta), y + size * Math.sin(theta)];
  });
};

var hexCorners = exports.hexCorners = function hexCorners(type, x, y, size) {
  var diff = type === POINTY ? 30 : 0;
  return RANGE6.map(function (baseDeg) {
    var rad = Math.PI / 180 * (baseDeg + diff);
    return [x + size * Math.cos(rad), y + size * Math.sin(rad)];
  });
};

var gridPoint = exports.gridPoint = function gridPoint(oType, oX, oY, size, gridX, gridY) {
  /* eslint-disable no-else-return */
  /* reason: it seems buggy */
  if (oType === POINTY) {
    var height = size * 2;
    var width = size * SQRT3;
    var diffXFromY = gridY * width / 2;
    var gridPointX = gridX * width + diffXFromY;
    var gridPointY = gridY * height * 0.75;

    var x = gridPointX + oX;
    var y = gridPointY + oY;

    return {
      props: {
        type: oType,
        x: x,
        y: y,
        size: size
      },
      gridX: gridX,
      gridY: gridY,
      corners: hexCorners(oType, x, y, size)
    };
  } else if (oType === FLAT) {
    var _width = size * 2;
    var _height = size * SQRT3;
    var _diffXFromY = gridY * _width * 0.75;
    var _gridPointX = gridX * _width * 1.5 + _diffXFromY;
    var _gridPointY = gridY * _height / 2;

    var _x = _gridPointX + oX;
    var _y = _gridPointY + oY;

    return {
      props: {
        type: oType,
        x: _x,
        y: _y,
        size: size
      },
      gridX: gridX,
      gridY: gridY,
      corners: hexCorners(oType, _x, _y, size)
    };
  } else {
    throw new Error('grid oType was either ' + POINTY + ' or ' + FLAT);
  }
  /* eslint-enable no-else-return */
};

var gridPoints = exports.gridPoints = function gridPoints(oType, oX, oY, size, gridWidth, gridHeight) {
  return product(gridHeight, gridWidth).map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        gridY = _ref2[0],
        gridX = _ref2[1];

    return gridPoint(oType, oX, oY, size, gridX, gridY);
  });
};