{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gridPoints = exports.gridPoint = exports.hexCorners = exports.corners = undefined;\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _from = require('babel-runtime/core-js/array/from');\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable no-mixed-operators,consistent-return */\n\n\nvar THETAS = [0, 1, 2, 3, 4, 5].map(function (i) {\n  return Math.PI / 3 * i;\n});\nvar POINTY = 'pointy-topped';\nvar FLAT = 'flat-topped';\nvar RANGE6 = [0, 60, 120, 180, 240, 300];\nvar SQRT3 = Math.sqrt(3);\n\nvar getDiff = function getDiff(type) {\n  if (type === POINTY) return Math.PI / 6;\n  if (type === FLAT) return 0;\n};\n\nvar range = function range(n) {\n  return (0, _from2.default)(Array(n).keys());\n};\n\nvar product = function product(p, q) {\n  var l = [];\n  range(p).forEach(function (i) {\n    range(q).forEach(function (j) {\n      l.push([i, j]);\n    });\n  });\n  return l;\n};\n\nvar corners = exports.corners = function corners(type, x, y, size) {\n  var diff = getDiff(type);\n  return THETAS.map(function (theta) {\n    return theta + diff;\n  }).map(function (theta) {\n    return [x + size * Math.cos(theta), y + size * Math.sin(theta)];\n  });\n};\n\nvar hexCorners = exports.hexCorners = function hexCorners(type, x, y, size) {\n  var diff = type === POINTY ? 30 : 0;\n  return RANGE6.map(function (baseDeg) {\n    var rad = Math.PI / 180 * (baseDeg + diff);\n    return [x + size * Math.cos(rad), y + size * Math.sin(rad)];\n  });\n};\n\nvar gridPoint = exports.gridPoint = function gridPoint(oType, oX, oY, size, gridX, gridY) {\n  /* eslint-disable no-else-return */\n\n  /* reason: it seems buggy */\n  if (oType === POINTY) {\n    var height = size * 2;\n    var width = size * SQRT3;\n    var diffXFromY = gridY * width / 2;\n    var gridPointX = gridX * width + diffXFromY;\n    var gridPointY = gridY * height * 0.75;\n    var x = gridPointX + oX;\n    var y = gridPointY + oY;\n    return {\n      props: {\n        type: oType,\n        x: x,\n        y: y,\n        size: size\n      },\n      gridX: gridX,\n      gridY: gridY,\n      corners: hexCorners(oType, x, y, size)\n    };\n  } else if (oType === FLAT) {\n    var _width = size * 2;\n\n    var _height = size * SQRT3;\n\n    var _diffXFromY = gridY * _width * 0.75;\n\n    var _gridPointX = gridX * _width * 1.5 + _diffXFromY;\n\n    var _gridPointY = gridY * _height / 2;\n\n    var _x = _gridPointX + oX;\n\n    var _y = _gridPointY + oY;\n\n    return {\n      props: {\n        type: oType,\n        x: _x,\n        y: _y,\n        size: size\n      },\n      gridX: gridX,\n      gridY: gridY,\n      corners: hexCorners(oType, _x, _y, size)\n    };\n  } else {\n    throw new Error('grid oType was either ' + POINTY + ' or ' + FLAT);\n  }\n  /* eslint-enable no-else-return */\n\n};\n\nvar gridPoints = exports.gridPoints = function gridPoints(oType, oX, oY, size, gridWidth, gridHeight) {\n  return product(gridHeight, gridWidth).map(function (_ref) {\n    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),\n        gridY = _ref2[0],\n        gridX = _ref2[1];\n\n    return gridPoint(oType, oX, oY, size, gridX, gridY);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}